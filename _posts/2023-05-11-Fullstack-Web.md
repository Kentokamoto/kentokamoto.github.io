---
layout: post
title: Fullstack Web Dev
header: The world that is Web Development
---

I started my coding journey with doing assignments deriving and graphing out
differential equations for my physics classes, eventually making my way back to
CS for my grad degree, and finally landing a software job right after college
where I've stuck to working on backend systems full time. One of the things that
I had never really explored but had an itch to for a long time was fullstack web
development. I knew how the three main base ingredients (HTML, CSS, JavaScript)
worked but never really took the time to understand how all three of these
played together along with how content on a page was generated dynamically. So
once I got the news that I had been laid off of my current position, I took it
as an opportunity to really put my head down and learn web development.

I learn best by watching videos online instead of through reading documentation
online unfortunately so I signed up for a web development crash course on Udemy
to take me through the core concepts of web development. I wanted something just
taught web development with little to know frontend frameworks like Angular or
React since those can probably be learned pretty easily after picking on up the
basics of the core 3 pieces first. If this was the wrong way of approaching
learning about the web, future me, I'm sorry.

I finished the course back in February. There was this sign of relief not only
from completing the course but coming out with a better understanding of how the
stack plays together. One of the biggest takeaways for me was API design. Web
pages that involved some dynamic information involved some endpoint that needed
to be reached in order to know how to generate the page that was to follow after
a submission. Arguably, how a web page is laid out is entirely up to the web
designer but having a good API endpoint scoped out can make a huge difference in
how one may mentally map how to send and receive information accordingly. When
it comes to deploying a page, knowing what types of keys should be populated
into an environment variable is very important and how to populate those
environment variables on a web hosting page was very useful as well. Finally,
the class really emphasized to not reinvent the wheel by utilizing 3rd party
services like CDNs instead of managing every part of the service from end to
end, especially when you want to get something up and running quickly. Kind of
like how we import libraries/modules/crates into our programs just so we don't
have to write every part of the algorithm from scratch.

Since the class, it's become evident that the roles I am applying for requires
some basic web knowledge as well and this alone has got me thinking how glad I
was to take the time and learn this before starting the interview loop. Some
companies had me design and API endpoint from scratch while others wanted me to
crate a simple web page that dynamically loaded and removed elements on a page
that was to be processed on the backend. Yes, these take-home assignments are
awful and take a lot longer than what they say but I treated it as an
opportunity to try new things out. If that ended up getting me a job, great, if
not, no harm. I still feel like I gained something out of the exercise.

What's next for me? Here's what's top of mind for me:

1. Reread the Rust book
    - I've read it from cover to cover before but after going through the
      section on Javascript, I feel like I'll have a more full understanding of
      how concurrency works in this particular language.
2. Research web assembly(WASM) with Rust
    - The main reason why I wanted to learn Rust was so I could start looking
      into web assembly more seriously. In the current state of how WASM in rust
      works, there's some level of javascript that is still required to get a
      page working properly.
3. Progressive Web Apps (PWA):
    - I'm getting this strong feeling that native mobile apps are going to trend
      towards more web-based apps. This could avoid the need to create an iOS
      version and Android version of an app and have everything tied to a
      browser instead. Most of the mobile apps besides games and camera-based
      apps probably don't need a native app to get things done. The browser
      should be enough

As far as non-web related goals,

1. Docker
    - I know how to use dockerfiles and how docker-compose works but I feel like
      know how container orchestration works is just as important too. Maybe
      this can lead to something on the web? We'll find out.
